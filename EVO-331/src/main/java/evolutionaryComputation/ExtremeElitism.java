/*
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option) any later
 * version. This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details. You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin St,
 * Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Copyright © 2011-2012 Francisco Aisa Garcia and Ricardo Caballero Moral
 */
package evolutionaryComputation;

import org.apache.log4j.Logger;

import java.io.IOException;
import knowledge.Memoria;
import synchro.WorkQueueClient;
import utilities.Arithmetic;
import utilities.Copycat;
import utilities.Quicksort;

/**
 * The best 15 individuals continue to the next generation. The other 15 are
 * generated by crossover between the survivors with higher survival
 * probability.
 *
 * @author Francisco Aisa García
 */
public class ExtremeElitism extends GeneticAlg {

    /**
     * Logger for this class
     */
    private static final Logger logger = Logger.getLogger(ExtremeElitism.class);

    // *************************************************************************
    //                                METHODS
    // *************************************************************************
    /**
     * It initializes the genetic algorithm using the information stored in the
     * data base. If there isn't any information available, it generates the
     * first generation.
     *
     * @param GENERATIONS Number of generations to be executed.
     * @param populationSize Size of the population for each generation.
     * @param crossoverType Kind of crossover to be applied.
     * @param memory Data Base controller.
     */
    @Deprecated
    public ExtremeElitism(int GENERATIONS, int populationSize, CrossoverType crossoverType, Memoria memory) {
        super(GENERATIONS, populationSize, crossoverType);

        initPopulation();


        // Load stored information in the data base. If no information is available
        // then initialize everything randomly
        boolean success = load(memory);

        if (success) {
            // If the next individual to evaluate is the first one of the next population
            // check out if the next generation is the last one.
            // If it is the last one, store the best individual, otherwise, create
            // the next generation based on selection, crossover and mutation

            if (currentIndividual >= population.length) {
                // Write down the results
                Copycat.copyPopulation(currentGeneration, population);

                currentGeneration = currentGeneration + 1;

                if (currentGeneration == GENERATIONS) {
                    // The execution has ended, select the best individual (the one
                    // with the biggest fitness) and store it as a result in the
                    // data base

                    // Look for the best inidividual
                    double max = population[0].fitness();
                    int pos = 0;
                    for (int i = 1; i < population.length; ++i) {
                        if (population[i].fitness() >= max) {
                            max = population[i].fitness();
                            pos = i;
                        }
                    }

                    // Store the best individual
                    String tableName = population[pos].getClass().getName();
                    tableName = tableName.replace("evolutionaryComputation.", "");
                    memory.storeBestIndividuo(tableName, population[pos], false);

                    // Restart execution
                    currentGeneration = 0;
                    currentIndividual = 0;
                    currentMatch = 0;

                    for (int i = 0; i < population.length; ++i) {
                        population[i].createRandomIndividual();
                    }
                } else {
                    // Reset the next individual to be evaluated
                    currentIndividual = 0;
                    currentMatch = 0;

                    // Selection, Crossover and Mutation
                    selection();
                }
            }
        } else {
            currentGeneration = 0;
            currentIndividual = 0;
            currentMatch = 0;

            for (int i = 0; i < population.length; ++i) {
                population[i].createRandomIndividual();
            }
        }
    }



    /**
     * Select the best Individuals for the next population, mate them and mutate
     * them
     */
    @Override
	@Deprecated
    public void selection() {
        if (logger.isDebugEnabled()) {
            logger.debug("selection() - start"); //$NON-NLS-1$
        }

        // Sort the individuals based on their fitness
        Quicksort.sort(population);

        // Create the new population
        Individual[] newPopulation = new Individual[population.length];

        // Half of the new individuals are going to be passed by elitism
        for (int i = 0, k = population.length - 1; i < population.length / 2; ++i, --k) {
            newPopulation[i] = population[k];
        }

        // Generate the rest of the population following the roulette wheel
        // selection scheme
        int chances[] = new int[population.length];

        chances[0] = (int) (Math.round(population[0].fitness() * 10));
        for (int i = 1; i < population.length; ++i) {
            chances[i] = chances[i - 1] + (int) (Math.round(population[i].fitness() * 10));
        }

        // Create the new population
        for (int i = population.length / 2; i < population.length; ++i) {
            // Select by statistics an individual to survive
            int dice = Arithmetic.doRandomNumber(0, chances[population.length - 1]);

            boolean found = false;
            int survivorA = 0;
            for (int k = 0; k < population.length && !found; ++k) {
                if (dice <= chances[k]) {
                    survivorA = k;
                    found = true;
                }
            }

            // Get the other chromosome involved in reproduction by statistics
            int survivorB;
            boolean differentIndividual = false;
            do {
                dice = Arithmetic.doRandomNumber(0, chances[population.length - 1]);

                survivorB = 0;
                found = false;
                for (int k = 0; k < population.length && !found; ++k) {
                    if (dice <= chances[k]) {
                        if (k != survivorA) {
                            survivorB = k;
                            found = true;
                            differentIndividual = true;
                        } else {
                            differentIndividual = false;
                            found = true;
                        }
                    }
                }
            } while (!differentIndividual);

            newPopulation[i] = new IndividualV1(false, ComplexFitness.class);

            // =================================================================
            // UNIFORM CROSSOVER
            // =================================================================
            for (int locus = 0; locus < newPopulation[i].chromosomeSize(); ++locus) {
                double probability = Math.random();

                if (probability > 0.5) {
                    newPopulation[i].setGene(locus, population[survivorA].getGene(locus));
                } else {
                    newPopulation[i].setGene(locus, population[survivorB].getGene(locus));
                }
            }

            // =================================================================
            // MUTATION
            // =================================================================
            double chanceOfMutation = 1.0 / chromosomeSize;
            double rate = 0.1;

            for (int locus = 0; locus < newPopulation[i].chromosomeSize(); ++locus) {
                double probability = Math.random();

                if (probability < chanceOfMutation) {
                    if (Math.random() < 0.5) {
                        newPopulation[i].setGene(locus, newPopulation[i].getGene(locus) + (int) (rate * newPopulation[i].getGene(locus)));
                    } else {
                        int res = newPopulation[i].getGene(locus) - (int) (rate * newPopulation[i].getGene(locus));

                        // Avoid negative gene values
                        if (res < 0) {
                            newPopulation[i].setGene(locus, 0);
                        } else {
                            newPopulation[i].setGene(locus, res);
                        }
                    }
                }
            }
        }

        // Reset stats of the copied individuals
        for (int i = 0; i < population.length / 2; ++i) {
            newPopulation[i].resetStats();
        }

        population = newPopulation;

        if (logger.isDebugEnabled()) {
            logger.debug("selection() - end"); //$NON-NLS-1$
        }
    }

    //__________________________________________________________________________
    /**
     * Load all the genetic algorithm information using the values given by the
     * server.
     */
    public void loadFromServer() {
        if (logger.isDebugEnabled()) {
            logger.debug("loadFromServer() - start"); //$NON-NLS-1$
        }

        WorkQueueClient workClient = new WorkQueueClient(4000);


        try {
            //Get current individual ID from server

            synchro.SyncMessage id = workClient.readMessage(null);
            this.setCurrentIndividual(id.getId());
            if (logger.isDebugEnabled()) {
                logger.debug("loadFromServer() - ID recibido= " + id.getId()); //$NON-NLS-1$
            }
            id = workClient.readMessage(null);
            this.currentGeneration = id.getId();
            if (logger.isDebugEnabled()) {
                logger.debug("loadFromServer() - Generación recibida= " + id.getId()); //$NON-NLS-1$
            }

        } catch (IOException ex) {
            logger.error("loadFromServer()", ex); //$NON-NLS-1$
        } catch (ClassNotFoundException ex) {
            logger.error("loadFromServer()", ex); //$NON-NLS-1$
        }


        if (logger.isDebugEnabled()) {
            logger.debug("loadFromServer() - end"); //$NON-NLS-1$
        }
        workClient.close();
    }

    /**
     * Store all the genetic algorithm information in the data base.
     *
     * @param memory Data Base controller.
     */
    @Override
	public void store(Memoria memory) {
        if (logger.isDebugEnabled()) {
            logger.debug("store(Memoria) - start"); //$NON-NLS-1$
        }

        memory.storeGenes(currentIndividual, currentGeneration, currentMatch, population);

        if (logger.isDebugEnabled()) {
            logger.debug("store(Memoria) - end"); //$NON-NLS-1$
        }
    }
}
